=== PROJECT FILES DUMP ===


--- START: backend\CMakeLists.txt ---
cmake_minimum_required(VERSION 3.21)
project(oop_backend LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(unofficial-sqlite3 CONFIG REQUIRED)
find_package(Drogon CONFIG REQUIRED)
find_package(nlohmann_json CONFIG REQUIRED)
find_package(GTest CONFIG REQUIRED)

# ---- core ----
add_library(oop_core STATIC
    src/db/Db.cpp
    src/repos/ShipsRepo.cpp
    src/repos/PortsRepo.cpp
    src/repos/PeopleRepo.cpp
    src/repos/ShipTypesRepo.cpp
    src/repos/CrewRepo.cpp
)
target_include_directories(oop_core PUBLIC include)
target_link_libraries(oop_core PUBLIC
    nlohmann_json::nlohmann_json
    unofficial::sqlite3::sqlite3
)

# ---- server ----
add_executable(oop_backend
    src/main.cpp
    src/controllers/ShipsController.cpp
    src/controllers/PortsController.cpp
    src/controllers/PeopleController.cpp
    src/controllers/ShipTypesController.cpp
    src/controllers/CrewController.cpp
    src/controllers/OopDemoController.cpp
)
target_include_directories(oop_backend PRIVATE include)
target_link_libraries(oop_backend PRIVATE Drogon::Drogon oop_core)

# ---- tests ----
add_executable(oop_tests
    tests/ShipsRepoTests.cpp
    tests/PeopleRepoTests.cpp
    tests/ShipTypesRepoTests.cpp
)
target_include_directories(oop_tests PRIVATE include)
target_link_libraries(oop_tests PRIVATE oop_core GTest::gtest GTest::gtest_main)

enable_testing()
add_test(NAME AllRepoTests COMMAND oop_tests)
--- END ---

--- START: backend\CMakePresets.json ---
{
  "version": 6,
  "cmakeMinimumRequired": { "major": 3, "minor": 21 },
  "configurePresets": [
    {
      "name": "x64-Release",
      "displayName": "VS2022 x64 (Release)",
      "generator": "Visual Studio 17 2022",
      "architecture": { "value": "x64" },
      "binaryDir": "${sourceDir}/build/${presetName}",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
      }
    },
    {
      "name": "x64-Debug",
      "displayName": "VS2022 x64 (Debug)",
      "generator": "Visual Studio 17 2022",
      "architecture": { "value": "x64" },
      "binaryDir": "${sourceDir}/build/${presetName}",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
      }
    }
  ],
  "buildPresets": [
    { "name": "build-release", "configurePreset": "x64-Release" },
    { "name": "build-debug",   "configurePreset": "x64-Debug" }
  ]
}
--- END ---

--- START: backend\config.json ---
{
  "app": {
    "threads_num": 1,
    "document_root": "./public",
    "upload_path": "./uploads",
    "log_path": "./logs",
    "log_level": "TRACE"
  },
  "listeners": [
    { "address": "127.0.0.1", "port": 8081 }
  ],
  "ssl": { "use_ssl": false }
}
--- END ---

--- START: backend\include\controllers\CompaniesController.h ---
#pragma once
#include <drogon/HttpController.h>
#include <cstdint>

class CompaniesController : public drogon::HttpController<CompaniesController> {
public:
    METHOD_LIST_BEGIN
        ADD_METHOD_TO(CompaniesController::list,  "/api/companies", drogon::Get);
        ADD_METHOD_TO(CompaniesController::create,"/api/companies", drogon::Post);
        ADD_METHOD_TO(CompaniesController::getOne,"/api/companies/{1}", drogon::Get);
        ADD_METHOD_TO(CompaniesController::update,"/api/companies/{1}", drogon::Put);
        ADD_METHOD_TO(CompaniesController::remove,"/api/companies/{1}", drogon::Delete);

        ADD_METHOD_TO(CompaniesController::listPorts, "/api/companies/{1}/ports", drogon::Get);
        ADD_METHOD_TO(CompaniesController::addPort,   "/api/companies/{1}/ports", drogon::Post);
        ADD_METHOD_TO(CompaniesController::delPort,   "/api/companies/{1}/ports/{2}", drogon::Delete);

        ADD_METHOD_TO(CompaniesController::listShips, "/api/companies/{1}/ships", drogon::Get);
    METHOD_LIST_END

    void list   (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&);
    void create (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&);
    void getOne (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
    void update (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
    void remove (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);

    void listPorts(const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
    void addPort  (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
    void delPort  (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id, std::int64_t portId);

    void listShips(const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
};
--- END ---

--- START: backend\include\controllers\CrewController.h ---
#pragma once
#include <drogon/HttpController.h>

class CrewController : public drogon::HttpController<CrewController> {
public:
    METHOD_LIST_BEGIN
        ADD_METHOD_TO(CrewController::listByShip,  "/api/ships/{1}/crew", drogon::Get);
        ADD_METHOD_TO(CrewController::assign,      "/api/crew/assign",    drogon::Post);
        ADD_METHOD_TO(CrewController::endByPerson, "/api/crew/end",       drogon::Post);
    METHOD_LIST_END

    void listByShip (const drogon::HttpRequestPtr&, std::function<void (const drogon::HttpResponsePtr &)> &&cb, long long shipId);
    void assign     (const drogon::HttpRequestPtr&, std::function<void (const drogon::HttpResponsePtr &)> &&cb);
    void endByPerson(const drogon::HttpRequestPtr&, std::function<void (const drogon::HttpResponsePtr &)> &&cb);
};
--- END ---

--- START: backend\include\controllers\OopDemoController.h ---
#pragma once
#include <drogon/HttpController.h>

class OopDemoController : public drogon::HttpController<OopDemoController> {
public:
    METHOD_LIST_BEGIN
        ADD_METHOD_TO(OopDemoController::people, "/api/demo/oop/people", drogon::Get);
        ADD_METHOD_TO(OopDemoController::ships,  "/api/demo/oop/ships",  drogon::Get);
    METHOD_LIST_END

    void people(const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&);
    void ships (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&);
};
--- END ---

--- START: backend\include\controllers\PeopleController.h ---
#pragma once
#include <drogon/HttpController.h>
#include <cstdint>

class PeopleController : public drogon::HttpController<PeopleController> {
public:
    METHOD_LIST_BEGIN
        ADD_METHOD_TO(PeopleController::list,      "/api/people",     drogon::Get);
        ADD_METHOD_TO(PeopleController::create,    "/api/people",     drogon::Post);
        ADD_METHOD_TO(PeopleController::getOne,    "/api/people/{1}", drogon::Get);
        ADD_METHOD_TO(PeopleController::updateOne, "/api/people/{1}", drogon::Put);
        ADD_METHOD_TO(PeopleController::deleteOne, "/api/people/{1}", drogon::Delete);
    METHOD_LIST_END

    void list     (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&);
    void create   (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&);
    void getOne   (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
    void updateOne(const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
    void deleteOne(const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
};
--- END ---

--- START: backend\include\controllers\PortsController.h ---
#pragma once
#include <drogon/HttpController.h>

class PortsController : public drogon::HttpController<PortsController> {
public:
    METHOD_LIST_BEGIN
        ADD_METHOD_TO(PortsController::list, "/api/ports", drogon::Get);
    METHOD_LIST_END

    void list(const drogon::HttpRequestPtr&,
              std::function<void(const drogon::HttpResponsePtr&)>&&);
};
--- END ---

--- START: backend\include\controllers\ShipsController.h ---
#pragma once
#include <drogon/HttpController.h>
#include <cstdint>

class ShipsController : public drogon::HttpController<ShipsController> {
public:
    METHOD_LIST_BEGIN
        ADD_METHOD_TO(ShipsController::list,     "/api/ships",       drogon::Get);
        ADD_METHOD_TO(ShipsController::create,   "/api/ships",       drogon::Post);
        ADD_METHOD_TO(ShipsController::getOne,   "/api/ships/{1}",   drogon::Get);
        ADD_METHOD_TO(ShipsController::updateOne,"/api/ships/{1}",   drogon::Put);
        ADD_METHOD_TO(ShipsController::deleteOne,"/api/ships/{1}",   drogon::Delete);
    METHOD_LIST_END

    void list    (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&);
    void create  (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&);
    void getOne  (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
    void updateOne(const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
    void deleteOne(const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
};
--- END ---

--- START: backend\include\controllers\ShipTypesController.h ---
#pragma once
#include <drogon/HttpController.h>
#include <cstdint>

class ShipTypesController : public drogon::HttpController<ShipTypesController> {
public:
    METHOD_LIST_BEGIN
        ADD_METHOD_TO(ShipTypesController::list,      "/api/ship-types",     drogon::Get);
        ADD_METHOD_TO(ShipTypesController::create,    "/api/ship-types",     drogon::Post);
        ADD_METHOD_TO(ShipTypesController::getOne,    "/api/ship-types/{1}", drogon::Get);
        ADD_METHOD_TO(ShipTypesController::updateOne, "/api/ship-types/{1}", drogon::Put);
        ADD_METHOD_TO(ShipTypesController::deleteOne, "/api/ship-types/{1}", drogon::Delete);
    METHOD_LIST_END

    void list     (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&);
    void create   (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&);
    void getOne   (const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
    void updateOne(const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
    void deleteOne(const drogon::HttpRequestPtr&, std::function<void(const drogon::HttpResponsePtr&)>&&, std::int64_t id);
};
--- END ---

--- START: backend\include\db\Db.cpp ---
#include "db/Db.h"
#include <filesystem>
#include <stdexcept>

static inline void execOrThrow(sqlite3* db, const char* sql) {
    char* err = nullptr;
    int rc = sqlite3_exec(db, sql, nullptr, nullptr, &err);
    if (rc != SQLITE_OK) {
        std::string msg = err ? err : "unknown";
        sqlite3_free(err);
        throw std::runtime_error("sqlite exec failed: " + msg);
    }
}

Db& Db::instance() {
    static Db inst;
    return inst;
}

Db::Db() {
    namespace fs = std::filesystem;
    fs::create_directories("data");          // РІС–РґРЅРѕСЃРЅРѕ СЂРѕР±РѕС‡РѕРіРѕ РєР°С‚Р°Р»РѕРіСѓ
    const char* path = "data/app.db";
    if (sqlite3_open(path, &db_) != SQLITE_OK) {
        throw std::runtime_error("sqlite open failed");
    }
    runMigrations();                         // РіР°СЂР°РЅС‚СѓС”РјРѕ СЃС…РµРјСѓ РѕРґСЂР°Р·Сѓ
}

Db::~Db() {
    if (db_) sqlite3_close(db_);
}

void Db::runMigrations() {
    const char* sql =
        "PRAGMA foreign_keys=ON;"
        "CREATE TABLE IF NOT EXISTS ships ("
        "  id   INTEGER PRIMARY KEY AUTOINCREMENT,"
        "  name TEXT NOT NULL UNIQUE"
        ");";
    execOrThrow(db_, sql);
}

void Db::reset() {
    char* err = nullptr;
    sqlite3_exec(db_, "DELETE FROM ships;", nullptr, nullptr, &err);
    if (err) sqlite3_free(err);
}
--- END ---

--- START: backend\include\db\Db.h ---
#pragma once
#include <sqlite3.h>

class Db {
public:
    static Db& instance();

    sqlite3* handle() const noexcept { return db_; }
    void runMigrations();  // створення/оновлення схеми
    void reset();          // очистити дані ships (для тестів)

    Db(const Db&) = delete;
    Db& operator=(const Db&) = delete;

private:
    Db();
    ~Db();
    sqlite3* db_ = nullptr;
};
--- END ---

--- START: backend\include\domain\Engineer.h ---
#pragma once
#include "domain/Person.h"
#include <utility>

class Engineer : public Person {
public:
    Engineer(std::string name, std::string specialty)
        : Person(std::move(name)), specialty_(std::move(specialty)) {}

    const std::string& specialty() const noexcept { return specialty_; }
    void setSpecialty(std::string v) { specialty_ = std::move(v); }

    std::string role() const override { return "Engineer"; }
    std::string duty() const override { return "Maintain ship systems"; }

private:
    std::string specialty_;
};
--- END ---

--- START: backend\include\domain\Person.h ---
#pragma once
#include <string>
#include <utility>

class Person {
public:
    explicit Person(std::string name) : name_(std::move(name)) {}
    virtual ~Person() = default;

    const std::string& name() const noexcept { return name_; }
    void setName(std::string v) { name_ = std::move(v); }

    virtual std::string role() const = 0;
    virtual std::string duty() const = 0;

private:
    std::string name_;
};
--- END ---

--- START: backend\include\domain\Port.h ---
#pragma once
#include <string>
#include <utility>

class PortBase {
public:
    PortBase(std::string name, std::string region)
        : name_(std::move(name)), region_(std::move(region)) {}
    virtual ~PortBase() = default;

    const std::string& name() const noexcept { return name_; }
    const std::string& region() const noexcept { return region_; }
    void setName(std::string v) { name_ = std::move(v); }
    void setRegion(std::string v) { region_ = std::move(v); }

    virtual std::string kind() const { return "Seaport"; }

private:
    std::string name_;
    std::string region_;
};
--- END ---

--- START: backend\include\domain\Researcher.h ---
#pragma once
#include "domain/Person.h"
#include <utility>

class Researcher : public Person {
public:
    Researcher(std::string name, std::string field)
        : Person(std::move(name)), field_(std::move(field)) {}

    const std::string& field() const noexcept { return field_; }
    void setField(std::string v) { field_ = std::move(v); }

    std::string role() const override { return "Researcher"; }
    std::string duty() const override { return "Conduct experiments"; }

private:
    std::string field_;
};
--- END ---

--- START: backend\include\domain\ShipDomain.h ---
#pragma once
#include <string>
#include <utility>

class ShipBase {
public:
    ShipBase(std::string name, double tonnage)
        : name_(std::move(name)), tonnage_(tonnage) {}
    virtual ~ShipBase() = default;

    const std::string& name() const noexcept { return name_; }
    double tonnage() const noexcept { return tonnage_; }
    void setName(std::string v) { name_ = std::move(v); }
    void setTonnage(double t) { tonnage_ = t; }

    virtual std::string category() const = 0;
    virtual std::string mission()  const = 0;

private:
    std::string name_;
    double tonnage_{};
};

class CargoShip : public ShipBase {
public:
    CargoShip(std::string name, double tonnage, double capacityTons)
        : ShipBase(std::move(name), tonnage), capacityTons_(capacityTons) {}
    double capacityTons() const noexcept { return capacityTons_; }
    std::string category() const override { return "Cargo"; }
    std::string mission()  const override { return "Transport goods"; }
private:
    double capacityTons_;
};

class MilitaryShip : public ShipBase {
public:
    MilitaryShip(std::string name, double tonnage, int weapons)
        : ShipBase(std::move(name), tonnage), weapons_(weapons) {}
    int weapons() const noexcept { return weapons_; }
    std::string category() const override { return "Military"; }
    std::string mission()  const override { return "Defense and security"; }
private:
    int weapons_;
};

class ResearchShip : public ShipBase {
public:
    ResearchShip(std::string name, double tonnage, int labs)
        : ShipBase(std::move(name), tonnage), labs_(labs) {}
    int labs() const noexcept { return labs_; }
    std::string category() const override { return "Research"; }
    std::string mission()  const override { return "Scientific exploration"; }
private:
    int labs_;
};
--- END ---

--- START: backend\include\domain\Soldier.h ---
#pragma once
#include "domain/Person.h"
#include <utility>

class Soldier : public Person {
public:
    Soldier(std::string name, std::string rank)
        : Person(std::move(name)), rank_(std::move(rank)) {}

    const std::string& rank() const noexcept { return rank_; }
    void setRank(std::string v) { rank_ = std::move(v); }

    std::string role() const override { return "Soldier"; }
    std::string duty() const override { return "Defend and protect"; }

private:
    std::string rank_;
};
--- END ---

--- START: backend\include\models\Company.h ---
#pragma once
#include <string>
#include <cstdint>

struct Company {
    std::int64_t id = 0;
    std::string  name;
};
--- END ---

--- START: backend\include\models\CrewAssignment.h ---
#pragma once
#include <cstdint>
#include <string>
#include <optional>

struct CrewAssignment {
    std::int64_t id = 0;
    std::int64_t person_id = 0;
    std::int64_t ship_id = 0;
    std::string  start_date;                // YYYY-MM-DD
    std::optional<std::string> end_date;    // null => Р°РєС‚РёРІРЅРµ
};
--- END ---

--- START: backend\include\models\Person.h ---
#pragma once
#include <string>
#include <cstdint>

struct Person {
    std::int64_t id = 0;
    std::string  full_name;   // NOT NULL
    std::string  rank;        // наприклад "Captain", "Mate"
    int          active = 1;  // 1|0
};
--- END ---

--- START: backend\include\models\Ship.h ---
#pragma once
#include <string>
#include <cstdint>

struct Ship {
    std::int64_t id      = 0;
    std::string  name;         // NOT NULL
    std::string  type;         // "Cargo"/"Military"/"Passenger"/...
    std::string  country;      // країна прапора
    std::int64_t port_id = 0;  // FK -> ports.id (може бути 0, тоді присвоїмо дефолтний порт)
    std::string  status  = "docked";
    std::int64_t company_id = 0; // FK -> companies.id (0 => відсутня)
};
--- END ---

--- START: backend\include\models\ShipType.h ---
#pragma once
#include <string>
#include <cstdint>

struct ShipType {
    std::int64_t id = 0;
    std::string  code;        // унікальний ключ, напр. "cargo"
    std::string  name;        // читабельна назва, напр. "Cargo"
    std::string  description; // опціонально
};
--- END ---

--- START: backend\include\repos\CompaniesRepo.h ---
#pragma once
#include <vector>
#include <optional>
#include <cstdint>
#include <string>
#include "models/Company.h"
#include "repos/PortsRepo.h"
#include "models/Ship.h"

class CompaniesRepo {
public:
    std::vector<Company> all();
    std::optional<Company> byId(std::int64_t id);
    Company create(const std::string& name);
    bool update(std::int64_t id, const std::string& name);
    bool remove(std::int64_t id);

    // офіси компанії
    std::vector<Port> ports(std::int64_t companyId);
    bool addPort(std::int64_t companyId, std::int64_t portId, bool isHq);
    bool removePort(std::int64_t companyId, std::int64_t portId);

    // кораблі компанії
    std::vector<Ship> ships(std::int64_t companyId);
};
--- END ---

--- START: backend\include\repos\CrewRepo.cpp ---
#include "repos/CrewRepo.h"
#include "db/Db.h"
#include <sqlite3.h>
#include <stdexcept>

static CrewAssignment parseRow(sqlite3_stmt* st) {
    CrewAssignment a;
    a.id        = sqlite3_column_int64(st, 0);
    a.person_id = sqlite3_column_int64(st, 1);
    a.ship_id   = sqlite3_column_int64(st, 2);
    const unsigned char* sd = sqlite3_column_text(st, 3);
    a.start_date = sd ? reinterpret_cast<const char*>(sd) : "";
    if (sqlite3_column_type(st, 4) != SQLITE_NULL) {
        const unsigned char* ed = sqlite3_column_text(st, 4);
        a.end_date = std::string(ed ? reinterpret_cast<const char*>(ed) : "");
    } else {
        a.end_date.reset();
    }
    return a;
}

std::vector<CrewAssignment> CrewRepo::activeByShip(long long shipId) {
    std::vector<CrewAssignment> out;
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id,person_id,ship_id,start_date,end_date FROM crew_assignments "
                      "WHERE ship_id=? AND end_date IS NULL ORDER BY id";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;
    sqlite3_bind_int64(st, 1, shipId);
    while (sqlite3_step(st) == SQLITE_ROW) out.push_back(parseRow(st));
    sqlite3_finalize(st);
    return out;
}

std::vector<CrewAssignment> CrewRepo::historyByPerson(long long personId) {
    std::vector<CrewAssignment> out;
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id,person_id,ship_id,start_date,end_date FROM crew_assignments "
                      "WHERE person_id=? ORDER BY id";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;
    sqlite3_bind_int64(st, 1, personId);
    while (sqlite3_step(st) == SQLITE_ROW) out.push_back(parseRow(st));
    sqlite3_finalize(st);
    return out;
}

CrewAssignment CrewRepo::assign(long long personId, long long shipId, const std::string& startDate) {
    sqlite3* db = Db::instance().handle();

    // РїРµСЂРµРІС–СЂРєР° СѓРЅС–РєР°Р»СЊРЅРѕСЃС‚С– Р°РєС‚РёРІРЅРѕС— РїРѕСЃР°РґРєРё
    {
        const char* chk = "SELECT id FROM crew_assignments WHERE person_id=? AND end_date IS NULL LIMIT 1";
        sqlite3_stmt* st{};
        sqlite3_prepare_v2(db, chk, -1, &st, nullptr);
        sqlite3_bind_int64(st, 1, personId);
        bool hasActive = (sqlite3_step(st) == SQLITE_ROW);
        sqlite3_finalize(st);
        if (hasActive) throw std::runtime_error("person already has an active assignment");
    }

    const char* ins = "INSERT INTO crew_assignments(person_id,ship_id,start_date) "
                      "VALUES(?,?,COALESCE(NULLIF(?,''), date('now')))";
    sqlite3_stmt* st{};
    sqlite3_prepare_v2(db, ins, -1, &st, nullptr);
    sqlite3_bind_int64(st, 1, personId);
    sqlite3_bind_int64(st, 2, shipId);
    sqlite3_bind_text (st, 3, startDate.c_str(), -1, SQLITE_TRANSIENT);

    if (sqlite3_step(st) != SQLITE_DONE) {
        std::string msg = sqlite3_errmsg(db);
        sqlite3_finalize(st);
        throw std::runtime_error("insert failed: " + msg);
    }
    sqlite3_finalize(st);

    long long id = sqlite3_last_insert_rowid(db);
    const char* sel = "SELECT id,person_id,ship_id,start_date,end_date FROM crew_assignments WHERE id=?";
    sqlite3_prepare_v2(db, sel, -1, &st, nullptr);
    sqlite3_bind_int64(st, 1, id);
    CrewAssignment a{};
    if (sqlite3_step(st) == SQLITE_ROW) a = parseRow(st);
    sqlite3_finalize(st);
    return a;
}

bool CrewRepo::endActiveByPerson(long long personId, const std::string& endDate) {
    sqlite3* db = Db::instance().handle();
    const char* upd = "UPDATE crew_assignments "
                      "SET end_date = COALESCE(NULLIF(?,''), date('now')) "
                      "WHERE person_id=? AND end_date IS NULL";
    sqlite3_stmt* st{};
    sqlite3_prepare_v2(db, upd, -1, &st, nullptr);
    sqlite3_bind_text (st, 1, endDate.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_int64(st, 2, personId);
    sqlite3_step(st);
    int changed = sqlite3_changes(db);
    sqlite3_finalize(st);
    return changed > 0;
}
--- END ---

--- START: backend\include\repos\CrewRepo.h ---
#pragma once
#include <string>
#include <vector>
#include <optional>

struct CrewAssignment {
    long long id = 0;
    long long person_id = 0;
    long long ship_id = 0;
    std::string start_utc;                       // ISO-8601 у UTC
    std::optional<std::string> end_utc;          // null => активне
};

class CrewRepo {
public:
    std::vector<CrewAssignment> currentCrewByShip(long long shipId);
    std::optional<CrewAssignment> assign(long long personId, long long shipId, const std::string& startUtc);
    bool endActiveByPerson(long long personId, const std::string& endUtc);
};
--- END ---

--- START: backend\include\repos\PeopleRepo.h ---
#pragma once
#include "models/Person.h"
#include <vector>
#include <optional>
#include <cstdint>

class PeopleRepo {
public:
    std::vector<Person> all();
    std::optional<Person> byId(long long id);
    Person create(const Person& p);
    void update(const Person& p);
    void remove(long long id);
};
--- END ---

--- START: backend\include\repos\PortsRepo.cpp ---
#include "repos/PortsRepo.h"
#include "db/Db.h"

std::vector<Port> PortsRepo::all() {
    std::vector<Port> out;
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id, name, region, lat, lon FROM ports ORDER BY region, name";
    
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;

    while (sqlite3_step(st) == SQLITE_ROW) {
        Port p;
        p.id = sqlite3_column_int64(st, 0);
        p.name = (const char*)sqlite3_column_text(st, 1);
        p.region = (const char*)sqlite3_column_text(st, 2);
        p.lat = sqlite3_column_double(st, 3);
        p.lon = sqlite3_column_double(st, 4);
        out.push_back(p);
    }
    sqlite3_finalize(st);
    return out;
}
--- END ---

--- START: backend\include\repos\PortsRepo.h ---
#pragma once
#include <vector>
#include <string>

struct Port {
    long long id;
    std::string name;
    std::string region;
    double lat;
    double lon;
};

class PortsRepo {
public:
    std::vector<Port> all();
};
--- END ---

--- START: backend\include\repos\ShipRepo.cpp ---
#include "repos/ShipsRepo.h"
#include "db/Db.h"
#include <sqlite3.h>

std::vector<Ship> ShipsRepo::all() {
    std::vector<Ship> out;
    sqlite3* db = Db::instance().handle();

    const char* sql = "SELECT id,name FROM ships ORDER BY id";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;

    while (sqlite3_step(st) == SQLITE_ROW) {
        Ship s;
        s.id   = sqlite3_column_int64(st, 0);
        const unsigned char* txt = sqlite3_column_text(st, 1);
        s.name = txt ? reinterpret_cast<const char*>(txt) : "";
        out.push_back(std::move(s));
    }
    sqlite3_finalize(st);
    return out;
}

std::optional<Ship> ShipsRepo::byId(long long id) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id,name FROM ships WHERE id=?";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return std::nullopt;

    sqlite3_bind_int64(st, 1, id);
    std::optional<Ship> out;
    if (sqlite3_step(st) == SQLITE_ROW) {
        Ship s;
        s.id   = sqlite3_column_int64(st, 0);
        const unsigned char* txt = sqlite3_column_text(st, 1);
        s.name = txt ? reinterpret_cast<const char*>(txt) : "";
        out = std::move(s);
    }
    sqlite3_finalize(st);
    return out;
}

std::optional<Ship> ShipsRepo::create(const std::string& name) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "INSERT INTO ships(name) VALUES(?)";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return std::nullopt;

    sqlite3_bind_text(st, 1, name.c_str(), -1, SQLITE_TRANSIENT);
    if (sqlite3_step(st) != SQLITE_DONE) {
        sqlite3_finalize(st);
        return std::nullopt;
    }
    sqlite3_finalize(st);

    long long id = sqlite3_last_insert_rowid(db);
    return byId(id);
}

bool ShipsRepo::update(long long id, const std::string& name) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "UPDATE ships SET name=? WHERE id=?";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return false;

    sqlite3_bind_text(st, 1, name.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_int64(st, 2, id);

    bool ok = (sqlite3_step(st) == SQLITE_DONE);
    int changed = sqlite3_changes(db);
    sqlite3_finalize(st);
    return ok && (changed > 0);
}

bool ShipsRepo::remove(long long id) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "DELETE FROM ships WHERE id=?";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return false;

    sqlite3_bind_int64(st, 1, id);
    bool ok = (sqlite3_step(st) == SQLITE_DONE);
    int changed = sqlite3_changes(db);
    sqlite3_finalize(st);
    return ok && (changed > 0);
}
--- END ---

--- START: backend\include\repos\ShipsRepo.h ---
#pragma once
#include "models/Ship.h"
#include <vector>
#include <optional>

class ShipsRepo {
public:
    std::vector<Ship> all();
    std::vector<Ship> getByPortId(long long portId);

    Ship create(const Ship& s);
    std::optional<Ship> byId(long long id);
    void update(const Ship& s);
    void remove(long long id);
};
--- END ---

--- START: backend\include\repos\ShipTypesRepo.h ---
#pragma once
#include "models/ShipType.h"
#include <vector>
#include <optional>

class ShipTypesRepo {
public:
    std::vector<ShipType> all();
    std::optional<ShipType> byId(long long id);
    std::optional<ShipType> byCode(const std::string& code);
    ShipType create(const ShipType& t);  // повертає створений запис
    void update(const ShipType& t);
    void remove(long long id);
};
--- END ---

--- START: backend\logs\run.err.txt ---
--- END ---

--- START: backend\logs\run.out.txt ---
--- END ---

--- START: backend\src\controllers\CompaniesController.cpp ---
#include "controllers/CompaniesController.h"
#include "repos/CompaniesRepo.h"
#include <json/json.h>
using namespace drogon;

static HttpResponsePtr jerr(const std::string& msg, HttpStatusCode code) {
    Json::Value e; e["error"]=msg; auto r=HttpResponse::newHttpJsonResponse(e); r->setStatusCode(code); return r;
}

void CompaniesController::list(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb) {
    CompaniesRepo repo;
    auto vec = repo.all();
    Json::Value arr(Json::arrayValue);
    for (auto& c : vec) { Json::Value j; j["id"]=Json::Int64(c.id); j["name"]=c.name; arr.append(j); }
    cb(HttpResponse::newHttpJsonResponse(arr));
}

void CompaniesController::create(const HttpRequestPtr& req, std::function<void(const HttpResponsePtr&)>&& cb) {
    auto j = req->getJsonObject(); if (!j || !(*j).isMember("name")) { cb(jerr("name required", k400BadRequest)); return; }
    try {
        CompaniesRepo repo; auto c = repo.create((*j)["name"].asString());
        Json::Value out; out["id"]=Json::Int64(c.id); out["name"]=c.name; cb(HttpResponse::newHttpJsonResponse(out));
    } catch (...) { cb(jerr("create failed", k500InternalServerError)); }
}

void CompaniesController::getOne(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    CompaniesRepo repo; auto c = repo.byId(id); if (!c) { cb(jerr("not found", k404NotFound)); return; }
    Json::Value out; out["id"]=Json::Int64(c->id); out["name"]=c->name; cb(HttpResponse::newHttpJsonResponse(out));
}

void CompaniesController::update(const HttpRequestPtr& req, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    auto j = req->getJsonObject(); if (!j || !(*j).isMember("name")) { cb(jerr("name required", k400BadRequest)); return; }
    CompaniesRepo repo; bool ok = repo.update(id, (*j)["name"].asString());
    if (!ok) { cb(jerr("not found or unchanged", k404NotFound)); return; }
    Json::Value out; out["status"]="updated"; cb(HttpResponse::newHttpJsonResponse(out));
}

void CompaniesController::remove(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    CompaniesRepo repo; bool ok = repo.remove(id);
    if (!ok) { cb(jerr("not found", k404NotFound)); return; }
    auto r = HttpResponse::newHttpResponse(); r->setStatusCode(k204NoContent); cb(r);
}

void CompaniesController::listPorts(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    CompaniesRepo repo; auto vec = repo.ports(id);
    Json::Value arr(Json::arrayValue);
    for (auto& p : vec) { Json::Value j; j["id"]=Json::Int64(p.id); j["name"]=p.name; j["region"]=p.region; j["lat"]=p.lat; j["lon"]=p.lon; arr.append(j); }
    cb(HttpResponse::newHttpJsonResponse(arr));
}

void CompaniesController::addPort(const HttpRequestPtr& req, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    auto j = req->getJsonObject(); if (!j || !(*j).isMember("port_id")) { cb(jerr("port_id required", k400BadRequest)); return; }
    bool isHq = (*j).isMember("is_hq") ? (*j)["is_hq"].asBool() : false;
    CompaniesRepo repo; bool ok = repo.addPort(id, (*j)["port_id"].asInt64(), isHq);
    if (!ok) { cb(jerr("already exists or invalid", k400BadRequest)); return; }
    Json::Value out; out["status"]="added"; cb(HttpResponse::newHttpJsonResponse(out));
}

void CompaniesController::delPort(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id, std::int64_t portId) {
    CompaniesRepo repo; bool ok = repo.removePort(id, portId);
    if (!ok) { cb(jerr("not found", k404NotFound)); return; }
    auto r = HttpResponse::newHttpResponse(); r->setStatusCode(k204NoContent); cb(r);
}

void CompaniesController::listShips(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    CompaniesRepo repo; auto vec = repo.ships(id);
    Json::Value arr(Json::arrayValue);
    for (auto& s : vec) {
        Json::Value j; j["id"]=Json::Int64(s.id); j["name"]=s.name; j["type"]=s.type; j["country"]=s.country;
        j["port_id"]=Json::Int64(s.port_id); j["status"]=s.status; j["company_id"]=Json::Int64(s.company_id);
        arr.append(j);
    }
    cb(HttpResponse::newHttpJsonResponse(arr));
}
--- END ---

--- START: backend\src\controllers\CrewController.cpp ---
#include "controllers/CrewController.h"
#include "repos/CrewRepo.h"
#include <json/json.h>
using namespace drogon;

static HttpResponsePtr jerr(const std::string& msg, HttpStatusCode code) {
    Json::Value e; e["error"] = msg;
    auto r = HttpResponse::newHttpJsonResponse(e);
    r->setStatusCode(code);
    return r;
}

void CrewController::listByShip(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb, long long shipId) {
    CrewRepo repo;
    auto list = repo.currentCrewByShip(shipId);
    Json::Value arr(Json::arrayValue);
    for (const auto& a : list) {
        Json::Value j;
        j["id"]        = (Json::Int64)a.id;
        j["person_id"] = (Json::Int64)a.person_id;
        j["ship_id"]   = (Json::Int64)a.ship_id;
        j["start_utc"] = a.start_utc;
        if (a.end_utc.has_value()) j["end_utc"] = *a.end_utc; else j["end_utc"] = Json::nullValue;
        arr.append(j);
    }
    cb(HttpResponse::newHttpJsonResponse(arr));
}

void CrewController::assign(const HttpRequestPtr& req, std::function<void(const HttpResponsePtr&)>&& cb) {
    auto j = req->getJsonObject();
    if (!j || !(*j).isMember("person_id") || !(*j).isMember("ship_id")) {
        cb(jerr("person_id and ship_id are required", k400BadRequest));
        return;
    }
    long long personId = (*j)["person_id"].asInt64();
    long long shipId   = (*j)["ship_id"].asInt64();
    std::string start  = (*j).isMember("start_utc") ? (*j)["start_utc"].asString() : "2025-01-01T00:00:00Z";

    CrewRepo repo;
    auto created = repo.assign(personId, shipId, start);
    if (!created) {
        cb(jerr("failed to assign (maybe already active)", k409Conflict));
        return;
    }

    Json::Value out;
    out["id"]        = (Json::Int64)created->id;
    out["person_id"] = (Json::Int64)created->person_id;
    out["ship_id"]   = (Json::Int64)created->ship_id;
    out["start_utc"] = created->start_utc;
    out["end_utc"]   = created->end_utc ? Json::Value(*created->end_utc) : Json::Value(Json::nullValue);
    cb(HttpResponse::newHttpJsonResponse(out));
}

void CrewController::endByPerson(const HttpRequestPtr& req, std::function<void(const HttpResponsePtr&)>&& cb) {
    auto j = req->getJsonObject();
    if (!j || !(*j).isMember("person_id") || !(*j).isMember("end_utc")) {
        cb(jerr("person_id and end_utc are required", k400BadRequest));
        return;
    }
    long long personId = (*j)["person_id"].asInt64();
    std::string end    = (*j)["end_utc"].asString();

    CrewRepo repo;
    bool ok = repo.endActiveByPerson(personId, end);
    if (!ok) { cb(jerr("no active assignment", k404NotFound)); return; }

    Json::Value out; out["status"] = "ended";
    cb(HttpResponse::newHttpJsonResponse(out));
}
--- END ---

--- START: backend\src\controllers\OopDemoController.cpp ---
#include "controllers/OopDemoController.h"
#include "domain/Engineer.h"
#include "domain/Researcher.h"
#include "domain/Soldier.h"
#include "domain/ShipDomain.h"
#include <json/json.h>
#include <memory>
#include <vector>

using namespace drogon;

void OopDemoController::people(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb) {
    std::vector<std::unique_ptr<Person>> team;
    team.emplace_back(std::make_unique<Engineer>("Alice", "Electrical"));
    team.emplace_back(std::make_unique<Researcher>("Bob", "Oceanography"));
    team.emplace_back(std::make_unique<Soldier>("Eve", "Lieutenant"));

    Json::Value arr(Json::arrayValue);
    for (auto& p : team) {
        Json::Value j;
        j["name"] = p->name();
        j["role"] = p->role();
        j["duty"] = p->duty();
        if (auto e = dynamic_cast<Engineer*>(p.get()))   j["specialty"] = e->specialty();
        if (auto r = dynamic_cast<Researcher*>(p.get())) j["field"]     = r->field();
        if (auto s = dynamic_cast<Soldier*>(p.get()))    j["rank"]      = s->rank();
        arr.append(j);
    }
    cb(HttpResponse::newHttpJsonResponse(arr));
}

void OopDemoController::ships(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb) {
    std::vector<std::unique_ptr<ShipBase>> fleet;
    fleet.emplace_back(std::make_unique<CargoShip>("Mriya Sea", 12000.0, 8000.0));
    fleet.emplace_back(std::make_unique<MilitaryShip>("Defender", 15000.0, 12));
    fleet.emplace_back(std::make_unique<ResearchShip>("Explorer", 9000.0, 3));

    Json::Value arr(Json::arrayValue);
    for (auto& s : fleet) {
        Json::Value j;
        j["name"]     = s->name();
        j["tonnage"]  = s->tonnage();
        j["category"] = s->category();
        j["mission"]  = s->mission();
        if (auto c = dynamic_cast<CargoShip*>(s.get()))     j["capacity_tons"] = c->capacityTons();
        if (auto m = dynamic_cast<MilitaryShip*>(s.get()))  j["weapons"]       = m->weapons();
        if (auto r = dynamic_cast<ResearchShip*>(s.get()))  j["labs"]          = r->labs();
        arr.append(j);
    }
    cb(HttpResponse::newHttpJsonResponse(arr));
}
--- END ---

--- START: backend\src\controllers\PeopleController.cpp ---
#include "controllers/PeopleController.h"
#include "repos/PeopleRepo.h"
#include <json/json.h>
using namespace drogon;

static HttpResponsePtr jerr(const std::string& msg, HttpStatusCode code) {
    Json::Value e; e["error"] = msg;
    auto r = HttpResponse::newHttpJsonResponse(e);
    r->setStatusCode(code);
    return r;
}

void PeopleController::list(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb) {
    PeopleRepo repo; auto vec = repo.all();
    Json::Value arr(Json::arrayValue);
    for (const auto& p : vec) {
        Json::Value j;
        j["id"]        = Json::Int64(p.id);
        j["full_name"] = p.full_name;
        j["rank"]      = p.rank;
        j["active"]    = (p.active != 0);
        arr.append(j);
    }
    cb(HttpResponse::newHttpJsonResponse(arr));
}

void PeopleController::create(const HttpRequestPtr& req, std::function<void(const HttpResponsePtr&)>&& cb) {
    auto j = req->getJsonObject();
    if (!j || !(*j).isMember("full_name")) { cb(jerr("full_name is required", k400BadRequest)); return; }
    PeopleRepo repo;
    Person p;
    p.full_name = (*j)["full_name"].asString();
    p.rank      = (*j).isMember("rank")   ? (*j)["rank"].asString()   : "";
    p.active    = (*j).isMember("active") ? ((*j)["active"].asBool()?1:0) : 1;
    try {
        auto created = repo.create(p);
        Json::Value out;
        out["id"]        = Json::Int64(created.id);
        out["full_name"] = created.full_name;
        out["rank"]      = created.rank;
        out["active"]    = (created.active != 0);
        cb(HttpResponse::newHttpJsonResponse(out));
    } catch (const std::exception& ex) {
        cb(jerr(ex.what(), k500InternalServerError));
    }
}

void PeopleController::getOne(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    PeopleRepo repo; auto p = repo.byId(id);
    if (!p) { cb(jerr("not found", k404NotFound)); return; }
    Json::Value j;
    j["id"]        = Json::Int64(p->id);
    j["full_name"] = p->full_name;
    j["rank"]      = p->rank;
    j["active"]    = (p->active != 0);
    cb(HttpResponse::newHttpJsonResponse(j));
}

void PeopleController::updateOne(const HttpRequestPtr& req, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    auto j = req->getJsonObject();
    if (!j) { cb(jerr("json body required", k400BadRequest)); return; }
    PeopleRepo repo; auto cur = repo.byId(id);
    if (!cur) { cb(jerr("not found", k404NotFound)); return; }
    Person p = *cur;
    if ((*j).isMember("full_name")) p.full_name = (*j)["full_name"].asString();
    if ((*j).isMember("rank"))      p.rank      = (*j)["rank"].asString();
    if ((*j).isMember("active"))    p.active    = (*j)["active"].asBool()?1:0;
    try {
        repo.update(p);
        Json::Value ok; ok["status"] = "updated";
        cb(HttpResponse::newHttpJsonResponse(ok));
    } catch (const std::exception& ex) {
        cb(jerr(ex.what(), k500InternalServerError));
    }
}

void PeopleController::deleteOne(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    PeopleRepo repo;
    try {
        repo.remove(id);
        auto r = HttpResponse::newHttpResponse();
        r->setStatusCode(k204NoContent);
        cb(r);
    } catch (const std::exception& ex) {
        cb(jerr(ex.what(), k500InternalServerError));
    }
}
--- END ---

--- START: backend\src\controllers\PortsController.cpp ---
#include "controllers/PortsController.h"
#include "repos/PortsRepo.h"
#include <json/json.h>
using namespace drogon;

void PortsController::list(const HttpRequestPtr&,
                           std::function<void(const HttpResponsePtr&)>&& cb)
{
    PortsRepo repo;
    auto ports = repo.all();
    Json::Value arr(Json::arrayValue);
    for (const auto& p : ports) {
        Json::Value j;
        j["id"]     = Json::Int64(p.id);
        j["name"]   = p.name;
        j["region"] = p.region;
        j["lat"]    = p.lat;
        j["lon"]    = p.lon;
        arr.append(j);
    }
    cb(HttpResponse::newHttpJsonResponse(arr));
}
--- END ---

--- START: backend\src\controllers\PortsController.h ---
#include "controllers/PortsController.h"
#include "repos/PortsRepo.h"
#include <json/json.h>

using namespace drogon;

void PortsController::list(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb) {
    PortsRepo repo;
    auto ports = repo.all();

    Json::Value arr(Json::arrayValue);
    for (const auto& p : ports) {
        Json::Value j;
        j["id"] = (Json::Int64)p.id;
        j["name"] = p.name;
        j["region"] = p.region;
        j["lat"] = p.lat;
        j["lon"] = p.lon;
        arr.append(j);
    }

    cb(HttpResponse::newHttpJsonResponse(arr));
}
--- END ---

--- START: backend\src\controllers\ShipsController.cpp ---
#include "controllers/ShipsController.h"
#include "repos/ShipsRepo.h"
#include <json/json.h>
using namespace drogon;

static HttpResponsePtr jerr(const std::string& msg, HttpStatusCode code) {
    Json::Value e; e["error"]=msg;
    auto r = HttpResponse::newHttpJsonResponse(e);
    r->setStatusCode(code);
    return r;
}

void ShipsController::list(const HttpRequestPtr&,
                           std::function<void(const HttpResponsePtr&)>&& cb)
{
    ShipsRepo repo;
    auto ships = repo.all();
    Json::Value arr(Json::arrayValue);
    for (const auto& s : ships) {
        Json::Value j;
        j["id"]      = Json::Int64(s.id);
        j["name"]    = s.name;
        j["type"]    = s.type;
        j["country"] = s.country;
        j["port_id"] = Json::Int64(s.port_id);
        j["status"]  = s.status;
        arr.append(j);
    }
    cb(HttpResponse::newHttpJsonResponse(arr));
}

void ShipsController::create(const HttpRequestPtr& req,
                             std::function<void(const HttpResponsePtr&)>&& cb)
{
    auto j = req->getJsonObject();
    if (!j || !(*j).isMember("name")) { cb(jerr("name is required", k400BadRequest)); return; }

    Ship s;
    s.name    = (*j)["name"].asString();
    s.type    = (*j).isMember("type")    ? (*j)["type"].asString()    : "Cargo";
    s.country = (*j).isMember("country") ? (*j)["country"].asString() : "Unknown";
    s.port_id = (*j).isMember("port_id") ? (*j)["port_id"].asInt64() : 1; s.company_id = (*j).isMember("company_id") ? (*j)["company_id"].asInt64() : 0;
    s.status  = (*j).isMember("status")  ? (*j)["status"].asString()  : "docked";

    try {
        ShipsRepo repo;
        Ship created = repo.create(s);
        Json::Value out;
        out["id"]      = Json::Int64(created.id);
        out["name"]    = created.name;
        out["type"]    = created.type;
        out["country"] = created.country;
        out["port_id"] = Json::Int64(created.port_id);
        out["status"]  = created.status;
        cb(HttpResponse::newHttpJsonResponse(out));
    } catch (...) {
        cb(jerr("failed to create", k500InternalServerError));
    }
}

void ShipsController::getOne(const HttpRequestPtr&,
                             std::function<void(const HttpResponsePtr&)>&& cb,
                             std::int64_t id)
{
    ShipsRepo repo;
    auto s = repo.byId(id);
    if (!s) { cb(jerr("not found", k404NotFound)); return; }

    Json::Value j;
    j["id"]      = Json::Int64(s->id);
    j["name"]    = s->name;
    j["type"]    = s->type;
    j["country"] = s->country;
    j["port_id"] = Json::Int64(s->port_id);
    j["status"]  = s->status;
    cb(HttpResponse::newHttpJsonResponse(j));
}

void ShipsController::updateOne(const HttpRequestPtr& req,
                                std::function<void(const HttpResponsePtr&)>&& cb,
                                std::int64_t id)
{
    auto j = req->getJsonObject();
    if (!j) { cb(jerr("json body required", k400BadRequest)); return; }

    ShipsRepo repo;
    auto cur = repo.byId(id);
    if (!cur) { cb(jerr("not found", k404NotFound)); return; }

    Ship s = *cur;
    if ((*j).isMember("name"))    s.name    = (*j)["name"].asString();
    if ((*j).isMember("type"))    s.type    = (*j)["type"].asString();
    if ((*j).isMember("country")) s.country = (*j)["country"].asString();
    if ((*j).isMember("port_id")) s.port_id = (*j)["port_id"].asInt64();
    if ((*j).isMember("status"))  s.status  = (*j)["status"].asString(); if ((*j).isMember("company_id")) s.company_id = (*j)["company_id"].asInt64();

    repo.update(s);
    Json::Value out; out["status"]="updated";
    cb(HttpResponse::newHttpJsonResponse(out));
}

void ShipsController::deleteOne(const HttpRequestPtr&,
                                std::function<void(const HttpResponsePtr&)>&& cb,
                                std::int64_t id)
{
    ShipsRepo repo;
    repo.remove(id);
    auto r = HttpResponse::newHttpResponse();
    r->setStatusCode(k204NoContent);
    cb(r);
}
--- END ---

--- START: backend\src\controllers\ShipsController.h ---
#pragma once
#include <drogon/HttpController.h>
#include <cstdint>

class ShipsController : public drogon::HttpController<ShipsController> {
public:
    METHOD_LIST_BEGIN
        ADD_METHOD_TO(ShipsController::list,   "/api/ships",     drogon::Get);        // СЃРїРёСЃРѕРє
        ADD_METHOD_TO(ShipsController::create, "/api/ships",     drogon::Post);       // СЃС‚РІРѕСЂРёС‚Рё
        ADD_METHOD_TO(ShipsController::getById,"/api/ships/{1}", drogon::Get);        // Р·Р° id
    METHOD_LIST_END

    void list(const drogon::HttpRequestPtr&, std::function<void (const drogon::HttpResponsePtr &)> &&cb);
    void create(const drogon::HttpRequestPtr&, std::function<void (const drogon::HttpResponsePtr &)> &&cb);
    void getById(const drogon::HttpRequestPtr&, std::function<void (const drogon::HttpResponsePtr &)> &&cb, std::int64_t id);
};
--- END ---

--- START: backend\src\controllers\ShipTypesController.cpp ---
#include "controllers/ShipTypesController.h"
#include "repos/ShipTypesRepo.h"
#include <json/json.h>
using namespace drogon;

static HttpResponsePtr jerr(const std::string& msg, HttpStatusCode code) {
    Json::Value e; e["error"] = msg;
    auto r = HttpResponse::newHttpJsonResponse(e);
    r->setStatusCode(code);
    return r;
}

void ShipTypesController::list(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb) {
    ShipTypesRepo repo; auto vec = repo.all();
    Json::Value arr(Json::arrayValue);
    for (const auto& t : vec) {
        Json::Value j;
        j["id"] = Json::Int64(t.id);
        j["code"] = t.code;
        j["name"] = t.name;
        j["description"] = t.description;
        arr.append(j);
    }
    cb(HttpResponse::newHttpJsonResponse(arr));
}

void ShipTypesController::create(const HttpRequestPtr& req, std::function<void(const HttpResponsePtr&)>&& cb) {
    auto j = req->getJsonObject();
    if (!j || !(*j).isMember("code") || !(*j).isMember("name"))
        { cb(jerr("code and name are required", k400BadRequest)); return; }
    ShipTypesRepo repo;
    ShipType t;
    t.code = (*j)["code"].asString();
    t.name = (*j)["name"].asString();
    t.description = (*j).isMember("description") ? (*j)["description"].asString() : "";
    try {
        auto created = repo.create(t);
        Json::Value out;
        out["id"] = Json::Int64(created.id);
        out["code"] = created.code;
        out["name"] = created.name;
        out["description"] = created.description;
        cb(HttpResponse::newHttpJsonResponse(out));
    } catch (const std::exception& ex) {
        cb(jerr(ex.what(), k500InternalServerError));
    }
}

void ShipTypesController::getOne(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    ShipTypesRepo repo; auto t = repo.byId(id);
    if (!t) { cb(jerr("not found", k404NotFound)); return; }
    Json::Value j;
    j["id"] = Json::Int64(t->id);
    j["code"] = t->code;
    j["name"] = t->name;
    j["description"] = t->description;
    cb(HttpResponse::newHttpJsonResponse(j));
}

void ShipTypesController::updateOne(const HttpRequestPtr& req, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    auto j = req->getJsonObject(); if (!j) { cb(jerr("json body required", k400BadRequest)); return; }
    ShipTypesRepo repo; auto cur = repo.byId(id); if (!cur) { cb(jerr("not found", k404NotFound)); return; }
    ShipType t = *cur;
    if ((*j).isMember("code")) t.code = (*j)["code"].asString();
    if ((*j).isMember("name")) t.name = (*j)["name"].asString();
    if ((*j).isMember("description")) t.description = (*j)["description"].asString();
    try { repo.update(t); Json::Value ok; ok["status"]="updated"; cb(HttpResponse::newHttpJsonResponse(ok)); }
    catch (const std::exception& ex) { cb(jerr(ex.what(), k500InternalServerError)); }
}

void ShipTypesController::deleteOne(const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb, std::int64_t id) {
    ShipTypesRepo repo;
    try {
        repo.remove(id);
        auto r = HttpResponse::newHttpResponse(); r->setStatusCode(k204NoContent); cb(r);
    } catch (const std::exception& ex) { cb(jerr(ex.what(), k500InternalServerError)); }
}
--- END ---

--- START: backend\src\db\Db.cpp ---
#include "db/Db.h"
#include <filesystem>
#include <stdexcept>
#include <string>
#include <iostream>

static void execOrThrow(sqlite3* db, const char* sql) {
    char* err = nullptr;
    int rc = sqlite3_exec(db, sql, nullptr, nullptr, &err);
    if (rc != SQLITE_OK) {
        std::string msg = err ? err : "unknown";
        if (err) sqlite3_free(err);
        throw std::runtime_error("sqlite exec failed: " + msg);
    }
}

Db& Db::instance() {
    static Db inst;
    return inst;
}

Db::Db() {
    namespace fs = std::filesystem;
    fs::create_directories("data");
    const char* path = "data/app.db";
    if (sqlite3_open(path, &db_) != SQLITE_OK) throw std::runtime_error("sqlite open failed");
    sqlite3_exec(db_, "PRAGMA foreign_keys = ON;", nullptr, nullptr, nullptr);
    runMigrations();
}

Db::~Db() {
    if (db_) sqlite3_close(db_);
}

void Db::runMigrations() {
    // --- PORTS ---
    execOrThrow(db_,
        "CREATE TABLE IF NOT EXISTS ports ("
        "  id INTEGER PRIMARY KEY AUTOINCREMENT,"
        "  name TEXT UNIQUE NOT NULL,"
        "  region TEXT NOT NULL,"
        "  lat REAL, lon REAL"
        ");"
    );

    // --- SHIP TYPES ---
    execOrThrow(db_,
        "CREATE TABLE IF NOT EXISTS ship_types ("
        "  id INTEGER PRIMARY KEY AUTOINCREMENT,"
        "  code TEXT UNIQUE NOT NULL,"
        "  name TEXT NOT NULL,"
        "  description TEXT"
        ");"
    );
    // seed ship_types
    execOrThrow(db_,
        "INSERT OR IGNORE INTO ship_types(code,name,description) VALUES"
        "('cargo','Cargo','General cargo / container'),"
        "('military','Military','Warship / patrol'),"
        "('passenger','Passenger','Ferry / cruise'),"
        "('tanker','Tanker','Oil / LNG / chemical'),"
        "('tug','Tug','Harbor tug / service'),"
        "('research','Research','Oceanographic / survey');"
    );

    // --- PEOPLE ---
    execOrThrow(db_,
        "CREATE TABLE IF NOT EXISTS people ("
        "  id INTEGER PRIMARY KEY AUTOINCREMENT,"
        "  full_name TEXT NOT NULL,"
        "  rank TEXT,"
        "  active INTEGER DEFAULT 1"
        ");"
    );

    // --- SHIPS ---
    execOrThrow(db_,
        "CREATE TABLE IF NOT EXISTS ships ("
        "  id INTEGER PRIMARY KEY AUTOINCREMENT,"
        "  name TEXT NOT NULL UNIQUE,"
        "  type TEXT NOT NULL,"
        "  country TEXT NOT NULL,"
        "  port_id INTEGER,"
        "  status TEXT DEFAULT 'docked',"
        "  FOREIGN KEY(port_id) REFERENCES ports(id)"
        ");"
    );

    // --- CREW ASSIGNMENTS ---
execOrThrow(db_,
    "CREATE TABLE IF NOT EXISTS crew_assignments ("
    "  id        INTEGER PRIMARY KEY AUTOINCREMENT,"
    "  person_id INTEGER NOT NULL,"
    "  ship_id   INTEGER NOT NULL,"
    "  start_utc TEXT    NOT NULL,"   // ISO-8601 UTC
    "  end_utc   TEXT,"               // NULL => активне
    "  FOREIGN KEY(person_id) REFERENCES people(id),"
    "  FOREIGN KEY(ship_id)   REFERENCES ships(id)"
    ");"
);

// Швидкі вибірки активних по кораблю
execOrThrow(db_,
    "CREATE INDEX IF NOT EXISTS idx_crew_ship_active "
    "ON crew_assignments(ship_id) WHERE end_utc IS NULL;"
);

// Гарантія: максимум 1 активне призначення на людину
execOrThrow(db_,
    "CREATE UNIQUE INDEX IF NOT EXISTS ux_crew_person_active "
    "ON crew_assignments(person_id) WHERE end_utc IS NULL;"
);

    // зручні індекси
    execOrThrow(db_, "CREATE INDEX IF NOT EXISTS crew_ship_idx ON crew_assignments(ship_id);");
    execOrThrow(db_, "CREATE INDEX IF NOT EXISTS crew_person_idx ON crew_assignments(person_id);");

    // --- seed PORTS if empty ---
    {
        sqlite3_stmt* st{};
        sqlite3_prepare_v2(db_, "SELECT count(*) FROM ports", -1, &st, nullptr);
        int cnt = 0; if (sqlite3_step(st) == SQLITE_ROW) cnt = sqlite3_column_int(st, 0);
        sqlite3_finalize(st);
        if (cnt == 0) {
            execOrThrow(db_,
                "INSERT INTO ports (name, region, lat, lon) VALUES "
                "('Rotterdam','Europe',51.9,4.4),"
                "('Hamburg','Europe',53.5,9.9),"
                "('Odessa','Europe',46.4,30.7),"
                "('New York','America',40.7,-74.0),"
                "('Shanghai','Asia',31.2,121.5);"
            );
            std::cout << "[Db] Ports seeded\n";
        }
    }

    // --- seed SHIPS if empty ---
    {
        sqlite3_stmt* st{};
        sqlite3_prepare_v2(db_, "SELECT count(*) FROM ships", -1, &st, nullptr);
        int sc = 0; if (sqlite3_step(st) == SQLITE_ROW) sc = sqlite3_column_int(st, 0);
        sqlite3_finalize(st);
        if (sc == 0) {
            execOrThrow(db_,
                "INSERT INTO ships (name, type, country, port_id) VALUES "
                "('Hetman Sahaydachny','Military','Ukraine',(SELECT id FROM ports WHERE name='Odessa')),"
                "('Mriya Sea','Cargo','Ukraine',(SELECT id FROM ports WHERE name='Odessa')),"
                "('USS Enterprise','Military','USA',(SELECT id FROM ports WHERE name='New York')),"
                "('Liberty Star','Passenger','USA',(SELECT id FROM ports WHERE name='New York')),"
                "('Cosco Hope','Cargo','China',(SELECT id FROM ports WHERE name='Shanghai')),"
                "('Red Dragon','Military','China',(SELECT id FROM ports WHERE name='Shanghai')),"
                "('Euro Queen','Passenger','Germany',(SELECT id FROM ports WHERE name='Hamburg'));"
            );
            std::cout << "[Db] Fleet seeded successfully!\n";
        }
    }
}

void Db::reset() {
    // для тестів: чистимо тільки crew & ships (довідники лишаємо)
    char* err = nullptr;
    sqlite3_exec(db_, "DELETE FROM crew_assignments;", nullptr, nullptr, &err); if (err) sqlite3_free(err);
    sqlite3_exec(db_, "DELETE FROM ships;", nullptr, nullptr, &err); if (err) sqlite3_free(err);
    sqlite3_exec(db_, "DELETE FROM sqlite_sequence WHERE name IN ('crew_assignments','ships');", nullptr, nullptr, &err);
    if (err) sqlite3_free(err);
}
--- END ---

--- START: backend\src\main.cpp ---
#include <drogon/drogon.h>
#include "db/Db.h"
using namespace drogon;

int main() {
    // Ініціалізуємо БД (створить схему та посіє порти за потреби)
    Db::instance();

    // Завантажуємо конфіг (порт 8081, шляхи logs/uploads, рівень логів тощо)
    app().loadConfigFile("config.json");

    // /health
    app().registerHandler("/health",
        [](const HttpRequestPtr&, std::function<void(const HttpResponsePtr&)>&& cb){
            auto r = HttpResponse::newHttpResponse();
            r->setContentTypeCode(CT_APPLICATION_JSON);
            r->setBody(R"({"status":"ok"})");
            cb(r);
        }, {Get});

    app().run();
}
--- END ---

--- START: backend\src\repos\CompaniesRepo.cpp ---
#include "repos/CompaniesRepo.h"
#include "db/Db.h"
#include <sqlite3.h>

static Company parseCompany(sqlite3_stmt* st) {
    Company c;
    c.id = sqlite3_column_int64(st, 0);
    c.name = reinterpret_cast<const char*>(sqlite3_column_text(st, 1));
    return c;
}

std::vector<Company> CompaniesRepo::all() {
    std::vector<Company> out;
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id,name FROM companies ORDER BY name";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;
    while (sqlite3_step(st) == SQLITE_ROW) out.push_back(parseCompany(st));
    sqlite3_finalize(st);
    return out;
}

std::optional<Company> CompaniesRepo::byId(std::int64_t id) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id,name FROM companies WHERE id=?";
    sqlite3_stmt* st{};
    sqlite3_prepare_v2(db, sql, -1, &st, nullptr);
    sqlite3_bind_int64(st, 1, id);
    std::optional<Company> out;
    if (sqlite3_step(st) == SQLITE_ROW) out = parseCompany(st);
    sqlite3_finalize(st);
    return out;
}

Company CompaniesRepo::create(const std::string& name) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "INSERT INTO companies(name) VALUES(?)";
    sqlite3_stmt* st{};
    sqlite3_prepare_v2(db, sql, -1, &st, nullptr);
    sqlite3_bind_text(st, 1, name.c_str(), -1, SQLITE_TRANSIENT);
    if (sqlite3_step(st) != SQLITE_DONE) { sqlite3_finalize(st); throw std::runtime_error("create company failed"); }
    sqlite3_finalize(st);
    auto id = sqlite3_last_insert_rowid(db);
    return byId(id).value();
}

bool CompaniesRepo::update(std::int64_t id, const std::string& name) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "UPDATE companies SET name=? WHERE id=?";
    sqlite3_stmt* st{};
    sqlite3_prepare_v2(db, sql, -1, &st, nullptr);
    sqlite3_bind_text(st, 1, name.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_int64(st, 2, id);
    bool ok = (sqlite3_step(st) == SQLITE_DONE) && sqlite3_changes(db) > 0;
    sqlite3_finalize(st);
    return ok;
}

bool CompaniesRepo::remove(std::int64_t id) {
    sqlite3* db = Db::instance().handle();
    // спочатку видалимо офіси, потім company, і обнулимо ships.company_id
    sqlite3_exec(db, "BEGIN", nullptr, nullptr, nullptr);
    sqlite3_stmt* st{};
    sqlite3_prepare_v2(db, "DELETE FROM company_ports WHERE company_id=?", -1, &st, nullptr);
    sqlite3_bind_int64(st, 1, id); sqlite3_step(st); sqlite3_finalize(st);

    sqlite3_prepare_v2(db, "UPDATE ships SET company_id=NULL WHERE company_id=?", -1, &st, nullptr);
    sqlite3_bind_int64(st, 1, id); sqlite3_step(st); sqlite3_finalize(st);

    sqlite3_prepare_v2(db, "DELETE FROM companies WHERE id=?", -1, &st, nullptr);
    sqlite3_bind_int64(st, 1, id); sqlite3_step(st);
    bool ok = sqlite3_changes(db) > 0;
    sqlite3_finalize(st);
    sqlite3_exec(db, "COMMIT", nullptr, nullptr, nullptr);
    return ok;
}

std::vector<Port> CompaniesRepo::ports(std::int64_t companyId) {
    std::vector<Port> out;
    sqlite3* db = Db::instance().handle();
    const char* sql =
        "SELECT p.id,p.name,p.region,p.lat,p.lon "
        "FROM company_ports cp JOIN ports p ON p.id=cp.port_id "
        "WHERE cp.company_id=? ORDER BY p.name";
    sqlite3_stmt* st{};
    sqlite3_prepare_v2(db, sql, -1, &st, nullptr);
    sqlite3_bind_int64(st, 1, companyId);
    while (sqlite3_step(st) == SQLITE_ROW) {
        Port p;
        p.id = sqlite3_column_int64(st, 0);
        p.name = reinterpret_cast<const char*>(sqlite3_column_text(st, 1));
        p.region = reinterpret_cast<const char*>(sqlite3_column_text(st, 2));
        p.lat = sqlite3_column_double(st, 3);
        p.lon = sqlite3_column_double(st, 4);
        out.push_back(p);
    }
    sqlite3_finalize(st);
    return out;
}

bool CompaniesRepo::addPort(std::int64_t companyId, std::int64_t portId, bool isHq) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "INSERT OR IGNORE INTO company_ports(company_id,port_id,is_hq) VALUES(?,?,?)";
    sqlite3_stmt* st{};
    sqlite3_prepare_v2(db, sql, -1, &st, nullptr);
    sqlite3_bind_int64(st, 1, companyId);
    sqlite3_bind_int64(st, 2, portId);
    sqlite3_bind_int(st, 3, isHq ? 1 : 0);
    bool ok = (sqlite3_step(st) == SQLITE_DONE) && sqlite3_changes(db) > 0;
    sqlite3_finalize(st);
    return ok;
}

bool CompaniesRepo::removePort(std::int64_t companyId, std::int64_t portId) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "DELETE FROM company_ports WHERE company_id=? AND port_id=?";
    sqlite3_stmt* st{};
    sqlite3_prepare_v2(db, sql, -1, &st, nullptr);
    sqlite3_bind_int64(st, 1, companyId);
    sqlite3_bind_int64(st, 2, portId);
    bool ok = (sqlite3_step(st) == SQLITE_DONE) && sqlite3_changes(db) > 0;
    sqlite3_finalize(st);
    return ok;
}

std::vector<Ship> CompaniesRepo::ships(std::int64_t companyId) {
    std::vector<Ship> out;
    sqlite3* db = Db::instance().handle();
    const char* sql =
        "SELECT id,name,type,country,port_id,status,COALESCE(company_id,0) "
        "FROM ships WHERE company_id=? ORDER BY id";
    sqlite3_stmt* st{};
    sqlite3_prepare_v2(db, sql, -1, &st, nullptr);
    sqlite3_bind_int64(st, 1, companyId);
    while (sqlite3_step(st) == SQLITE_ROW) {
        Ship s;
        s.id = sqlite3_column_int64(st, 0);
        s.name = reinterpret_cast<const char*>(sqlite3_column_text(st, 1));
        s.type = reinterpret_cast<const char*>(sqlite3_column_text(st, 2));
        s.country = reinterpret_cast<const char*>(sqlite3_column_text(st, 3));
        s.port_id = sqlite3_column_int64(st, 4);
        s.status = reinterpret_cast<const char*>(sqlite3_column_text(st, 5));
        s.company_id = sqlite3_column_int64(st, 6);
        out.push_back(s);
    }
    sqlite3_finalize(st);
    return out;
}
--- END ---

--- START: backend\src\repos\CrewRepo.cpp ---
#include "repos/CrewRepo.h"
#include "db/Db.h"
#include <sqlite3.h>

static inline CrewAssignment parseRow(sqlite3_stmt* st) {
    CrewAssignment a;
    a.id        = sqlite3_column_int64(st, 0);
    a.person_id = sqlite3_column_int64(st, 1);
    a.ship_id   = sqlite3_column_int64(st, 2);
    const unsigned char* s = sqlite3_column_text(st, 3);
    a.start_utc = s ? reinterpret_cast<const char*>(s) : "";
    const unsigned char* e = sqlite3_column_text(st, 4);
    if (e) a.end_utc = std::string(reinterpret_cast<const char*>(e));
    return a;
}

std::vector<CrewAssignment> CrewRepo::currentCrewByShip(long long shipId) {
    std::vector<CrewAssignment> out;
    sqlite3* db = Db::instance().handle();
    const char* sql =
        "SELECT id, person_id, ship_id, start_utc, end_utc "
        "FROM crew_assignments "
        "WHERE ship_id=? AND end_utc IS NULL "
        "ORDER BY id";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;
    sqlite3_bind_int64(st, 1, shipId);
    while (sqlite3_step(st) == SQLITE_ROW) out.push_back(parseRow(st));
    sqlite3_finalize(st);
    return out;
}

std::optional<CrewAssignment> CrewRepo::assign(long long personId, long long shipId, const std::string& startUtc) {
    sqlite3* db = Db::instance().handle();

    // 1 активне призначення на людину
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, "SELECT COUNT(*) FROM crew_assignments WHERE person_id=? AND end_utc IS NULL", -1, &st, nullptr) != SQLITE_OK)
        return std::nullopt;
    sqlite3_bind_int64(st, 1, personId);
    int cnt = 0; if (sqlite3_step(st) == SQLITE_ROW) cnt = sqlite3_column_int(st, 0);
    sqlite3_finalize(st);
    if (cnt > 0) return std::nullopt;

    // INSERT
    if (sqlite3_prepare_v2(db, "INSERT INTO crew_assignments(person_id, ship_id, start_utc) VALUES(?,?,?)", -1, &st, nullptr) != SQLITE_OK)
        return std::nullopt;
    sqlite3_bind_int64(st, 1, personId);
    sqlite3_bind_int64(st, 2, shipId);
    sqlite3_bind_text (st, 3, startUtc.c_str(), -1, SQLITE_TRANSIENT);
    if (sqlite3_step(st) != SQLITE_DONE) { sqlite3_finalize(st); return std::nullopt; }
    sqlite3_finalize(st);

    long long id = sqlite3_last_insert_rowid(db);

    // SELECT back
    if (sqlite3_prepare_v2(db, "SELECT id, person_id, ship_id, start_utc, end_utc FROM crew_assignments WHERE id=?", -1, &st, nullptr) != SQLITE_OK)
        return std::nullopt;
    sqlite3_bind_int64(st, 1, id);
    std::optional<CrewAssignment> out;
    if (sqlite3_step(st) == SQLITE_ROW) out = parseRow(st);
    sqlite3_finalize(st);
    return out;
}

bool CrewRepo::endActiveByPerson(long long personId, const std::string& endUtc) {
    sqlite3* db = Db::instance().handle();
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, "UPDATE crew_assignments SET end_utc=? WHERE person_id=? AND end_utc IS NULL", -1, &st, nullptr) != SQLITE_OK)
        return false;
    sqlite3_bind_text (st, 1, endUtc.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_int64(st, 2, personId);
    bool ok = (sqlite3_step(st) == SQLITE_DONE);
    int changed = sqlite3_changes(db);
    sqlite3_finalize(st);
    return ok && changed > 0;
}
--- END ---

--- START: backend\src\repos\PeopleRepo.cpp ---
#include "repos/PeopleRepo.h"
#include "db/Db.h"
#include <sqlite3.h>
#include <stdexcept>

static Person parse(sqlite3_stmt* st) {
    Person p;
    p.id = sqlite3_column_int64(st, 0);
    const unsigned char* t1 = sqlite3_column_text(st, 1);
    p.full_name = t1 ? reinterpret_cast<const char*>(t1) : "";
    const unsigned char* t2 = sqlite3_column_text(st, 2);
    p.rank = t2 ? reinterpret_cast<const char*>(t2) : "";
    p.active = sqlite3_column_int(st, 3);
    return p;
}

std::vector<Person> PeopleRepo::all() {
    std::vector<Person> out;
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id, full_name, rank, active FROM people ORDER BY id";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;
    while (sqlite3_step(st) == SQLITE_ROW) out.push_back(parse(st));
    sqlite3_finalize(st);
    return out;
}

std::optional<Person> PeopleRepo::byId(long long id) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id, full_name, rank, active FROM people WHERE id=?";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return std::nullopt;
    sqlite3_bind_int64(st, 1, id);
    std::optional<Person> out;
    if (sqlite3_step(st) == SQLITE_ROW) out = parse(st);
    sqlite3_finalize(st);
    return out;
}

Person PeopleRepo::create(const Person& p) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "INSERT INTO people(full_name, rank, active) VALUES (?,?,?)";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK)
        throw std::runtime_error(std::string("prepare failed: ") + sqlite3_errmsg(db));
    sqlite3_bind_text(st, 1, p.full_name.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(st, 2, p.rank.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(st, 3, p.active);
    if (sqlite3_step(st) != SQLITE_DONE) {
        std::string e = sqlite3_errmsg(db);
        sqlite3_finalize(st);
        throw std::runtime_error("insert failed: " + e);
    }
    sqlite3_finalize(st);
    auto id = sqlite3_last_insert_rowid(db);
    auto got = byId(id);
    if (!got) throw std::runtime_error("insert ok but fetch failed");
    return *got;
}

void PeopleRepo::update(const Person& p) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "UPDATE people SET full_name=?, rank=?, active=? WHERE id=?";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK)
        throw std::runtime_error(std::string("prepare failed: ") + sqlite3_errmsg(db));
    sqlite3_bind_text(st, 1, p.full_name.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(st, 2, p.rank.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(st, 3, p.active);
    sqlite3_bind_int64(st, 4, p.id);
    if (sqlite3_step(st) != SQLITE_DONE) {
        std::string e = sqlite3_errmsg(db);
        sqlite3_finalize(st);
        throw std::runtime_error("update failed: " + e);
    }
    sqlite3_finalize(st);
}

void PeopleRepo::remove(long long id) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "DELETE FROM people WHERE id=?";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK)
        throw std::runtime_error(std::string("prepare failed: ") + sqlite3_errmsg(db));
    sqlite3_bind_int64(st, 1, id);
    if (sqlite3_step(st) != SQLITE_DONE) {
        std::string e = sqlite3_errmsg(db);
        sqlite3_finalize(st);
        throw std::runtime_error("delete failed: " + e);
    }
    sqlite3_finalize(st);
}
--- END ---

--- START: backend\src\repos\PortsRepo.cpp ---
#include "repos/PortsRepo.h"
#include "db/Db.h"

std::vector<Port> PortsRepo::all() {
    std::vector<Port> out;
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id, name, region, lat, lon FROM ports ORDER BY region, name";
    
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;

    while (sqlite3_step(st) == SQLITE_ROW) {
        Port p;
        p.id = sqlite3_column_int64(st, 0);
        p.name = (const char*)sqlite3_column_text(st, 1);
        p.region = (const char*)sqlite3_column_text(st, 2);
        p.lat = sqlite3_column_double(st, 3);
        p.lon = sqlite3_column_double(st, 4);
        out.push_back(p);
    }
    sqlite3_finalize(st);
    return out;
}
--- END ---

--- START: backend\src\repos\ShipsRepo.cpp ---
#include "repos/ShipsRepo.h"
#include "db/Db.h"
#include <sqlite3.h>
#include <stdexcept>
#include <string>

// допоміжне: зчитати рядок в Ship
static Ship parseShip(sqlite3_stmt* st) {
    Ship s;
    s.id      = sqlite3_column_int64(st, 0);
    s.name    = reinterpret_cast<const char*>(sqlite3_column_text(st, 1));
    s.type    = reinterpret_cast<const char*>(sqlite3_column_text(st, 2));
    s.country = reinterpret_cast<const char*>(sqlite3_column_text(st, 3));
    s.port_id = sqlite3_column_int64(st, 4);
    s.status  = reinterpret_cast<const char*>(sqlite3_column_text(st, 5));
    return s;
}

// допоміжне: підібрати валідний port_id
static long long resolvePortId(sqlite3* db, long long desired) {
    // якщо заданий і існує — лишаємо
    if (desired > 0) {
        sqlite3_stmt* st{};
        if (sqlite3_prepare_v2(db, "SELECT 1 FROM ports WHERE id=? LIMIT 1", -1, &st, nullptr) == SQLITE_OK) {
            sqlite3_bind_int64(st, 1, desired);
            int rc = sqlite3_step(st);
            sqlite3_finalize(st);
            if (rc == SQLITE_ROW) return desired;
        }
        // інакше впадемо на підбір першого порту
    }
    // підбираємо перший доступний порт
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, "SELECT id FROM ports ORDER BY id LIMIT 1", -1, &st, nullptr) != SQLITE_OK) {
        throw std::runtime_error(std::string("resolvePortId prepare failed: ") + sqlite3_errmsg(db));
    }
    long long id = 0;
    if (sqlite3_step(st) == SQLITE_ROW) id = sqlite3_column_int64(st, 0);
    sqlite3_finalize(st);
    if (id == 0) throw std::runtime_error("No ports available; seed ports first");
    return id;
}

std::vector<Ship> ShipsRepo::all() {
    std::vector<Ship> out;
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id,name,type,country,port_id,status FROM ships ORDER BY id";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;
    while (sqlite3_step(st) == SQLITE_ROW) out.push_back(parseShip(st));
    sqlite3_finalize(st);
    return out;
}

std::vector<Ship> ShipsRepo::getByPortId(long long portId) {
    std::vector<Ship> out;
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id,name,type,country,port_id,status FROM ships WHERE port_id=? ORDER BY id";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;
    sqlite3_bind_int64(st, 1, portId);
    while (sqlite3_step(st) == SQLITE_ROW) out.push_back(parseShip(st));
    sqlite3_finalize(st);
    return out;
}

Ship ShipsRepo::create(const Ship& s) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "INSERT INTO ships(name,type,country,port_id,status) VALUES(?,?,?,?,?)";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) {
        throw std::runtime_error(std::string("prepare failed: ") + sqlite3_errmsg(db));
    }

    const std::string type    = s.type.empty()    ? "Cargo"   : s.type;
    const std::string country = s.country.empty() ? "Unknown" : s.country;
    const std::string status  = s.status.empty()  ? "docked"  : s.status;
    const long long   portId  = resolvePortId(db, s.port_id);

    sqlite3_bind_text (st, 1, s.name.c_str(),    -1, SQLITE_TRANSIENT);
    sqlite3_bind_text (st, 2, type.c_str(),      -1, SQLITE_TRANSIENT);
    sqlite3_bind_text (st, 3, country.c_str(),   -1, SQLITE_TRANSIENT);
    sqlite3_bind_int64(st, 4, portId);
    sqlite3_bind_text (st, 5, status.c_str(),    -1, SQLITE_TRANSIENT);

    if (sqlite3_step(st) != SQLITE_DONE) {
        std::string emsg = sqlite3_errmsg(db);
        sqlite3_finalize(st);
        throw std::runtime_error("insert failed: " + emsg);
    }
    sqlite3_finalize(st);

    long long id = sqlite3_last_insert_rowid(db);
    auto got = byId(id);
    if (!got) throw std::runtime_error("insert ok but fetch failed");
    return *got;
}

std::optional<Ship> ShipsRepo::byId(long long id) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id,name,type,country,port_id,status FROM ships WHERE id=?";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return std::nullopt;
    sqlite3_bind_int64(st, 1, id);
    std::optional<Ship> out;
    if (sqlite3_step(st) == SQLITE_ROW) out = parseShip(st);
    sqlite3_finalize(st);
    return out;
}

void ShipsRepo::update(const Ship& s) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "UPDATE ships SET name=?, type=?, country=?, port_id=?, status=?, company_id=? WHERE id=?";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) {
        throw std::runtime_error(std::string("prepare failed: ") + sqlite3_errmsg(db));
    }

    sqlite3_bind_text (st, 1, s.name.c_str(),    -1, SQLITE_TRANSIENT);
    sqlite3_bind_text (st, 2, s.type.c_str(),    -1, SQLITE_TRANSIENT);
    sqlite3_bind_text (st, 3, s.country.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_int64(st, 4, s.port_id);
    sqlite3_bind_text (st, 5, s.status.c_str(),  -1, SQLITE_TRANSIENT);
    sqlite3_bind_int64(st, 6, s.company_id); sqlite3_bind_int64(st, 7, s.id);

    if (sqlite3_step(st) != SQLITE_DONE) {
        std::string emsg = sqlite3_errmsg(db);
        sqlite3_finalize(st);
        throw std::runtime_error("update failed: " + emsg);
    }
    sqlite3_finalize(st);
}

void ShipsRepo::remove(long long id) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "DELETE FROM ships WHERE id=?";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) {
        throw std::runtime_error(std::string("prepare failed: ") + sqlite3_errmsg(db));
    }
    sqlite3_bind_int64(st, 1, id);
    if (sqlite3_step(st) != SQLITE_DONE) {
        std::string emsg = sqlite3_errmsg(db);
        sqlite3_finalize(st);
        throw std::runtime_error("delete failed: " + emsg);
    }
    sqlite3_finalize(st);
}
--- END ---

--- START: backend\src\repos\ShipTypesRepo.cpp ---
#include "repos/ShipTypesRepo.h"
#include "db/Db.h"
#include <sqlite3.h>
#include <stdexcept>

static ShipType parse_type(sqlite3_stmt* st) {
    ShipType t;
    t.id   = sqlite3_column_int64(st, 0);
    const unsigned char* c1 = sqlite3_column_text(st, 1);
    const unsigned char* c2 = sqlite3_column_text(st, 2);
    const unsigned char* c3 = sqlite3_column_text(st, 3);
    t.code        = c1 ? reinterpret_cast<const char*>(c1) : "";
    t.name        = c2 ? reinterpret_cast<const char*>(c2) : "";
    t.description = c3 ? reinterpret_cast<const char*>(c3) : "";
    return t;
}

std::vector<ShipType> ShipTypesRepo::all() {
    std::vector<ShipType> out;
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id, code, name, description FROM ship_types ORDER BY id";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return out;
    while (sqlite3_step(st) == SQLITE_ROW) out.push_back(parse_type(st));
    sqlite3_finalize(st);
    return out;
}

std::optional<ShipType> ShipTypesRepo::byId(long long id) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id, code, name, description FROM ship_types WHERE id=?";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return std::nullopt;
    sqlite3_bind_int64(st, 1, id);
    std::optional<ShipType> out;
    if (sqlite3_step(st) == SQLITE_ROW) out = parse_type(st);
    sqlite3_finalize(st);
    return out;
}

std::optional<ShipType> ShipTypesRepo::byCode(const std::string& code) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "SELECT id, code, name, description FROM ship_types WHERE code=?";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK) return std::nullopt;
    sqlite3_bind_text(st, 1, code.c_str(), -1, SQLITE_TRANSIENT);
    std::optional<ShipType> out;
    if (sqlite3_step(st) == SQLITE_ROW) out = parse_type(st);
    sqlite3_finalize(st);
    return out;
}

ShipType ShipTypesRepo::create(const ShipType& t) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "INSERT INTO ship_types(code,name,description) VALUES(?,?,?)";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK)
        throw std::runtime_error(std::string("prepare failed: ") + sqlite3_errmsg(db));
    sqlite3_bind_text(st, 1, t.code.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(st, 2, t.name.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(st, 3, t.description.c_str(), -1, SQLITE_TRANSIENT);
    if (sqlite3_step(st) != SQLITE_DONE) {
        std::string e = sqlite3_errmsg(db);
        sqlite3_finalize(st);
        throw std::runtime_error("insert failed: " + e);
    }
    sqlite3_finalize(st);
    auto id = sqlite3_last_insert_rowid(db);
    auto got = byId(id);
    if (!got) throw std::runtime_error("insert ok but fetch failed");
    return *got;
}

void ShipTypesRepo::update(const ShipType& t) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "UPDATE ship_types SET code=?, name=?, description=? WHERE id=?";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK)
        throw std::runtime_error(std::string("prepare failed: ") + sqlite3_errmsg(db));
    sqlite3_bind_text(st, 1, t.code.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(st, 2, t.name.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(st, 3, t.description.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_int64(st, 4, t.id);
    if (sqlite3_step(st) != SQLITE_DONE) {
        std::string e = sqlite3_errmsg(db);
        sqlite3_finalize(st);
        throw std::runtime_error("update failed: " + e);
    }
    sqlite3_finalize(st);
}

void ShipTypesRepo::remove(long long id) {
    sqlite3* db = Db::instance().handle();
    const char* sql = "DELETE FROM ship_types WHERE id=?";
    sqlite3_stmt* st{};
    if (sqlite3_prepare_v2(db, sql, -1, &st, nullptr) != SQLITE_OK)
        throw std::runtime_error(std::string("prepare failed: ") + sqlite3_errmsg(db));
    sqlite3_bind_int64(st, 1, id);
    if (sqlite3_step(st) != SQLITE_DONE) {
        std::string e = sqlite3_errmsg(db);
        sqlite3_finalize(st);
        throw std::runtime_error("delete failed: " + e);
    }
    sqlite3_finalize(st);
}
--- END ---

--- START: backend\tests\PeopleRepoTests.cpp ---
#include <gtest/gtest.h>
#include "repos/PeopleRepo.h"
#include "db/Db.h"

class PeopleRepoTest : public ::testing::Test {
protected:
    void SetUp() override { Db::instance().reset(); }
};

TEST_F(PeopleRepoTest, CreateGetUpdateDelete) {
    PeopleRepo repo;
    Person p; p.full_name = "John Doe"; p.rank = "Captain"; p.active = 1;

    auto created = repo.create(p);
    ASSERT_GT(created.id, 0);
    auto got = repo.byId(created.id);
    ASSERT_TRUE(got.has_value());
    EXPECT_EQ(got->full_name, "John Doe");

    created.rank = "Admiral";
    repo.update(created);
    auto upd = repo.byId(created.id);
    ASSERT_TRUE(upd.has_value());
    EXPECT_EQ(upd->rank, "Admiral");

    repo.remove(created.id);
    auto gone = repo.byId(created.id);
    EXPECT_FALSE(gone.has_value());
}
--- END ---

--- START: backend\tests\ShipsRepoTests.cpp ---
#include <gtest/gtest.h>
#include "repos/ShipsRepo.h"
#include "db/Db.h"

class ShipsRepoTest : public ::testing::Test {
protected:
    void SetUp() override {
        Db::instance().reset(); // Очистка перед тестом
    }
};

TEST_F(ShipsRepoTest, CreateAndGet) {
    ShipsRepo repo;
    Ship s;
    s.name = "Test Ship";
    s.type = "Cargo";
    s.country = "TestLand";
    s.port_id = 1;

    Ship created = repo.create(s);
    ASSERT_GT(created.id, 0);
    ASSERT_EQ(created.name, "Test Ship");
    ASSERT_EQ(created.type, "Cargo");

    auto fetched = repo.byId(created.id);
    ASSERT_TRUE(fetched.has_value());
    ASSERT_EQ(fetched->name, "Test Ship");
}

TEST_F(ShipsRepoTest, UpdateShip) {
    ShipsRepo repo;
    Ship s;
    s.name = "Old Name";
    s.type = "Military"; 
    s.country = "US";
    s.port_id = 1;
    
    Ship created = repo.create(s);
    
    created.name = "New Name";
    repo.update(created);

    auto updated = repo.byId(created.id);
    ASSERT_EQ(updated->name, "New Name");
    ASSERT_EQ(updated->type, "Military");
}

TEST_F(ShipsRepoTest, DeleteShip) {
    ShipsRepo repo;
    Ship s;
    s.name = "To Delete";
    s.type = "Tug";
    s.country = "UK";
    s.port_id = 1;

    Ship created = repo.create(s);
    repo.remove(created.id);

    auto deleted = repo.byId(created.id);
    ASSERT_FALSE(deleted.has_value());
}
--- END ---

--- START: backend\tests\ShipTypesRepoTests.cpp ---
#include <gtest/gtest.h>
#include "db/Db.h"
#include "repos/ShipTypesRepo.h"

class ShipTypesRepoTest : public ::testing::Test {
protected:
    void SetUp() override { Db::instance().reset(); }
};

TEST_F(ShipTypesRepoTest, CreateGetUpdateDelete) {
    ShipTypesRepo repo;
    ShipType t; t.code="icebreaker"; t.name="Icebreaker"; t.description="Arctic ops";
    auto created = repo.create(t);
    ASSERT_GT(created.id, 0);
    EXPECT_EQ(created.code, "icebreaker");

    auto got = repo.byId(created.id);
    ASSERT_TRUE(got.has_value());
    EXPECT_EQ(got->name, "Icebreaker");

    created.name = "Ice Breaker";
    repo.update(created);
    auto upd = repo.byId(created.id);
    ASSERT_TRUE(upd.has_value());
    EXPECT_EQ(upd->name, "Ice Breaker");

    repo.remove(created.id);
    auto gone = repo.byId(created.id);
    EXPECT_FALSE(gone.has_value());
}
--- END ---

--- START: backend\vcpkg.json ---
{
  "name": "oop-backend",
  "version-string": "0.1.0",
  "dependencies": [
    "drogon",
    "nlohmann-json",
    "sqlite3",
    "gtest"
  ]
}
--- END ---
